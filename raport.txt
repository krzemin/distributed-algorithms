

                      Maciej Jabłoński, Piotr Krzemiński

                  Raport do pracowni z Systemów Rozproszonych

                               24 lipca 2014r.



1. Opis zagadnienia

  Jako zadanie na pracownię został wybrany temat zaimplementowania kilku
klasycznych algorytmów rozproszonych w języku Erlang. Aglorytmy działają
w środowisku asynchronicznym, realizowanym przez wiele procesów. Dzięki
użyciu Erlanga łatwe staje się zapewnienie dwóch bardzo ważnych cech
w ujęciu systemów rozproszonych:

  - przenośności (ang. portability) -- zaimplementowane przez nas algorytmy
    uruchamiają się na różnych platformach sprzętowych; w naszych testach
    udało się połączyć w jednym algorytmie procesy Erlangowe, kontrolowane
    zarówno przez systemy Linux (w różnych wersjach), jak i Windows,

  - przezroczystości położenia (ang. location transparency) -- z punktu
    widzenia programu erlangowego nie ma znaczenia czy jednostka, do której
    wysyłamy komunikat znajduje się na tej samej fizycznej maszynie,
    na innym komputerze w tej samej sieci, czy też na zdalnej maszynie,
    być może na innym kontynencie

  Jako język programowania wybraliśmy Erlanga ze względu na jego specyficzne
właściwości, użyteczne podczas implementowania systemów współbieżnych,
szczegółowo opisane w podrozdziale 1.1.

1.1 Model procesów Erlanga

  Erlang powstał w laboratoriach firmy Ericsoon w latach '80 XX wieku,
początkowo jako projekt badawczy mający na celu przegląd istniejących
współcześnie języków programowania w kontekście ich użyteczności
do implementacji systemów współbieżnych. Okazało się, że żaden z ówcześnie
istniejących języków nie spełnia oczekiwanych kryteriów, wobec czego
postawnowiono zbudować nowy język, składniowo wzorowany na Prologu, który
jako model współbieżności przyjmie model aktorów (ang. Actor Model).

  W modelu aktorów, na scenie (w systemie) występują procesy, które mogą
komunikować się tylko przy użyciu komunikatów. Nie współdzielą ze sobą pamięci,
ani żadnych innych zasobów, wobec czego klasyczne metody synchronizacji,
takie jak semafory czy muteksy nie są potrzebne. Dzięki temu (przynajmniej
teoretycznie) wzrasta wydajność aplikacji, zwiększa się czytelność kodu,
mamy mniejsze szanse napotkania błędów (np. zakleszczenie), tak wszędobylskich
w systemach współbieżnych realizowanych za pomocą języków sekwencyjnych.

  Procesy erlangowe zaimplementowane są jako tzw. ultra-lekkie procesy,
których przy obecnych możliwościach pamięciowych możemy mieć setki tysięcy,
a nawet miliony na jednym komputerze!

  Niestety, Erlang nie gwarantuje dostarczenia komunikatu do odbiorcy
w kolejności, w jakiej zostały wysłane; nie gwarantuje jego dostarczenia
w ogóle! Toteż w związku ze zmianą paradygmatu myślenia o współbieżności,
pojawiają się nowe wyzwania, którym programista musi sprostać.

  Niemniej jednak Erlanga okrzyknięto pierwszym, powszechnie używanym
językiem współbieżnym. W ramach pracowni chcieliśmy zapoznać się z nim
poprzez implementację kilku prostych algorytmów współbieżnych, które
uruchomimy na klastrze złożonym z kilku komputerów.


2. Wymagania

  Do uruchomienia symulacji potrzebna jest maszyna wirtualna Erlanga,
najlepiej w aktualnej wersji (OTP 17.0). Oprogramowanie można pobrać
z witryny [1], dostępne w wersji binarnej dla systemu Windows lub w wersji
źródłowej dla pozostałych systemów.


3. Wykaz algorytmów
3.1 Algorytm rozgłaszania w grafie

3.1.1 Problem

  Dla zadanej sieci w postaci grafu dostarczyć wiadomość do każdego wierzchołka

3.1.2 Opis algorytmu

    I Wierzchołek A dostaje komunikat M od wierzchołka B.
   II A rozsyła M do sąsiadów z wyłączeniem B.
  III A zlicza sąsiadów od których otrzymał M. Po otrzymaniu jej od wszystkich
      kończy rozsyłanie
     
3.2 Algorytm rozgłaszania w hiperkostce

3.2.1 Problemu

  Problem tożsamy z 3.1.1 z dodanym założeniem o topologii sieci, która stanowi
hiperkostkę.

3.2.2 Opis algorytmu

    I Każdemu z wierzchołków zostaje przypisany numer zgodnie z kodowaniem Graya.
      Jeżeli wierzchołki mają numery, których zapis bitowy różni się jedynie na
      jednej pozycji, to są one sąsiadami. 
   II Wierzchołek A otrzymuje wiadomość M od procesu B.
  III Wyznaczamy D - pozycje bitu, który różni numery A i B.
   IV A rozsyła M do sąsiednich procesów, których numer różni się od A nie dalej
      niż na bicie numer D.
      
3.3 Wybór lidera

3.3.1 Problem

  Dla sieci o topologii pierścienia należy wybrać proces pełniący rolę lidera.

3.3.2 Opis algorytmu Changa-Robertsa
   
  Wykorzystaliśmy algorytm rozproszony zaproponowany przez Changa 
i Robertsa [2].
  
   I Początkowo każdy proces w pierścieniu jest oznaczony jako
     nieuczestniczący oraz ma przyznany niepowtarzalny identyfikator (UID).
  II Proces zauważający brak lidera rozpoczyna wybory. Tworzy on komunikat
    'election' zawierający UID, który wysyła do sąsiada zgodnie z ruchem
     wskazówek zegara.
 III Za każdym razem, kiedy proces wysyła lub przekazuje komunikat, oznacza
     samego siebie jako uczestnika.
  IV Proces otrzymując komunikat 'election' porównuje otrzymany
     identyfikator(A) z własnym (B)
     - jeżeli A > B to proces bezwarunkowo przekazuje komunikat do sąsiada
       zgodnie z ruchem wskazówek zegara,
     - jeżeli A < B i proces nie był jeszcze uczestnikiem to przesyła komunikat
       'election'  do sąsiada zgodnie z ruchem wskazówek zegara, zastępując A
       za pomocą B,
     - jeżeli A < B i proces był już uczestnikiem to proces ignoruje komunikat,
     - jeżeli A = B proces zostaje uznany za lideda.

Jako UID zastosowaliśmy identyfikatory procesów generowane przez Erlanga.
  
4. Instrukcja obsługi

  Aby uruchomić symulację, należy najpierw zainstalować w systemie maszynę
wirtualną erlanga, która dostarczy nam polecenia systemowego `erl` - powłoki
języka, przy pomocy której przeprowadzimy symulację. Następnie połączymy
kilka powłok w klaster, w którym powłoki będą pełnić rolę węzłów (ang. node).
Warto zaznaczyć, że w obrębie jednego węzła możemy uruchomić dowolną liczbę
procesów.


4.1 Tworzenie klastra


5. Bibliografia

  [1] http://www.erlang.org/download.html
  [2] Ernest Chang; Rosemary Roberts (1979), "An improved algorithm for
      decentralized extrema-finding in circular configurations of processes",
      Communications of the ACM (ACM) 22 (5): 281–283, 
      doi:10.1145/359104.359108
