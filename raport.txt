

                      Maciej Jabłoński, Piotr Krzemiński

                  Raport do pracowni z Systemów Rozproszonych



1. Opis zagadnienia

  Jako zadanie na pracownię został wybrany temat zaimplementowania kilku
klasycznych algorytmów rozproszonych w języku Erlang. Aglorytmy działają
w środowisku asynchronicznym, realizowanym przez wiele procesów. Dzięki
użyciu Erlanga łatwe staje się zapewnienie dwóch bardzo ważnych cech
w ujęciu systemów rozproszonych:

  - przenośności (ang. portability) -- zaimplementowane przez nas algorytmy
    uruchamiają się na różnych platformach sprzętowych; w naszych testach
    udało się połączyć w jednym algorytmie procesy Erlangowe, kontrolowane
    zarówno przez systemy Linux (w różnych wersjach), jak i Windows,

  - przezroczystości położenia (ang. location transparency) -- z punktu
    widzenia programu erlangowego nie ma znaczenia czy jednostka, do której
    wysyłamy komunikat znajduje się na tej samej fizycznej maszynie,
    na innym komputerze w tej samej sieci, czy też na zdalnej maszynie,
    być może na innym kontynencie

  Jako język programowania wybraliśmy Erlanga ze względu na jego specyficzne
właściwości, użyteczne podczas implementowania systemów współbieżnych,
szczegółowo opisane w podrozdziale 1.1.

1.1 Model procesów Erlanga

  Erlang powstał w laboratoriach firmy Ericsoon w latach '80 XX wieku,
początkowo jako projekt badawczy mający na celu przegląd istniejących
współcześnie języków programowania w kontekście ich użyteczności
do implementacji systemów współbieżnych. Okazało się, że żaden z ówcześnie
istniejących języków nie spełnia oczekiwanych kryteriów, wobec czego
postawnowiono zbudować nowy język, składniowo wzorowany na Prologu, który
jako model współbieżności przyjmie model aktorów (ang. Actor Model).

  W modelu aktorów, na scenie (w systemie) występują procesy, które mogą
komunikować się tylko przy użyciu komunikatów. Nie współdzielą ze sobą pamięci,
ani żadnych innych zasobów, wobec czego klasyczne metody synchronizacji,
takie jak semafory czy muteksy nie są potrzebne. Dzięki temu (przynajmniej
teoretycznie) wzrasta wydajność aplikacji, zwiększa się czytelność kodu,
mamy mniejsze szanse napotkania błędów (np. zakleszczenie), tak wszędobylskich
w systemach współbieżnych realizowanych za pomocą języków sekwencyjnych.

  Niestety, Erlang nie gwarantuje dostarczenia komunikatu do odbiorcy
w kolejności, w jakiej zostały wysłane; nie gwarantuje jego dostarczenia
w ogóle! Toteż w związku ze zmianą paradygmatu myślenia o współbieżności,
pojawiają się nowe wyzwania, którym programista musi sprostać.

  Niemniej jednak Erlang został okrzyknięty pierwszym, powszechnie używanym
językiem współbieżnym. W ramach pracowni chcieliśmy zapoznać się z nim
poprzez implementację kilku prostych algorytmów współbieżnych, które
uruchomimy na klastrze złożonym z kilku komputerów.


2. Wymagania

  Do uruchomienia symulacji potrzebna jest maszyna wirtualna Erlanga,
najlepiej w aktualnej wersji (OTP 17.0). Oprogramowanie można pobrać
z witryny [2], dostępne w wersji binarnej dla systemu Windows lub w wersji
źródłowej dla pozostałych systemów.


3. Wykaz algorytmów
3.1 broadcast
3.2 broadcast w kostce
3.3 wybór lidera
3.3.1 Problem

  Dla sieci o topologii pierścienia należy wybrać proces pełniący rolę lidera.

3.3.2 Algorytm Changa-Robertsa
   
  Wykorzystaliśmy algorytm rozproszony zaproponowany przez Changa 
i Robertsa [1].
  
  1. Początkowo każdy proces w pierścieniu jest oznaczony jako
     nieuczestniczący oraz ma przyznany niepowtarzalny identyfikator (UID).
  2. Proces zauważający brak lidera rozpoczyna wybory. Tworzy on komunikat
    'election' zawierający UID, który wysyła do sąsiada zgodnie z ruchem
     wskazówek zegara.
  3. Za każdym razem, kiedy proces wysyła lub przekazuje komunikat, oznacza
     samego siebie jako uczestnika.
  4. Proces otrzymując komunikat 'election' porównuje otrzymany
     identyfikator(A) z własnym(B)
     
    - jeżeli A > B to proces bezwarunkowo przekazuje komunikat do sąsiada
      zgodnie z ruchem wskazówek zegara.
    - jeżeli A < B i proces nie był jeszcze uczestnikiem to przesyła komunikat 
      'election'  do sąsiada zgodnie z ruchem wskazówek zegara, zastępując A za
      pomocą B.
    - jeżeli A < B i proces był już uczestnikiem to proces ignoruje komunikat.
    - jeżeli A = B proces zostaje uznany za lideda.

Jako UID zastosowaliśmy identyfikatory procesów generowane przez Erlanga.
  
4. Instrukcja obsługi

5. Bibliografia

  [1] Ernest Chang; Rosemary Roberts (1979), "An improved algorithm for
      decentralized extrema-finding in circular configurations of processes",
      Communications of the ACM (ACM) 22 (5): 281–283, 
      doi:10.1145/359104.359108
  [2] http://www.erlang.org/download.html
